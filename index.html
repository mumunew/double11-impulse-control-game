<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <!-- Safari专用元标签 -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-touch-fullscreen" content="yes">
  <meta name="format-detection" content="telephone=no">
  <title>双11钱包保卫战</title>
  <!-- Tailwind CSS v3 -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- 移除外部 Font Awesome 依赖，改用内联 SVG 图标 -->
  
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            primary: '#FF6B9D',
            secondary: '#7ED957',
            accent: '#56CCF2',
            gold: '#FFD700',
            pink: '#FF6B9D',
            blue: '#56CCF2',
            green: '#7ED957',
            yellow: '#FFD700',
            purple: '#9B59B6'
          },
          fontFamily: {
            sans: ['Arial Rounded MT Bold', 'Varela Round', 'sans-serif'],
          },
          animation: {
            'float': 'float 3s ease-in-out infinite',
            'sparkle': 'sparkle 2s ease-in-out infinite',
            'bounce-slow': 'bounce 2s infinite',
            'wiggle': 'wiggle 1s ease-in-out infinite',
          },
          keyframes: {
            float: {
              '0%, 100%': { transform: 'translateY(0)' },
              '50%': { transform: 'translateY(-10px)' },
            },
            sparkle: {
              '0%, 100%': { opacity: 1 },
              '50%': { opacity: 0.6 },
            },
            wiggle: {
              '0%, 100%': { transform: 'rotate(-3deg)' },
              '50%': { transform: 'rotate(3deg)' },
            }
          }
        }
      }
    }
  </script>
  
  <style type="text/tailwindcss">
    @layer utilities {
      .content-auto {
        content-visibility: auto;
      }
      .game-container {
        position: relative;
        width: 100%;
        height: calc(100vh - 32px); /* 为底部版权信息留出空间 */
        min-height: 500px; /* 确保最小高度 */
        overflow: hidden;
        touch-action: none;
      }
      
      /* 移动端适配 - 统一版本 */
      @media (max-width: 768px) {
        html, body {
          height: 100vh;
          overflow-x: hidden;
          margin: 0;
          padding: 0;
        }
        
        .game-container {
          height: 100vh;
          min-height: 500px;
          position: relative;
          overflow: hidden;
          /* iOS Safari 安全区域适配 */
          padding-bottom: env(safe-area-inset-bottom, 20px);
        }
        
        /* 微信浏览器适配 */
        body.wechat-browser .game-container {
          height: calc(100vh - 5px);
          min-height: calc(100vh - 5px);
        }
        
        /* Safari移动端适配 */
        body.safari-mobile .game-container {
          height: calc(100vh - 10px);
          min-height: calc(100vh - 10px);
        }
        
        /* 移动端按钮和界面元素优化 */
        .game-header {
          top: 5px;
          left: 5px;
          right: 5px;
          gap: 5px;
        }
      }
      
      .start-screen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 100;
        padding: 20px;
        text-align: center;
      }
      .hidden {
        display: none !important;
      }
      .legend {
        display: flex;
        gap: 20px;
        margin-top: 20px;
        flex-wrap: wrap;
        justify-content: center;
      }
      .legend-item {
        display: flex;
        align-items: center;
        gap: 10px;
        font-size: 16px;
        background-color: rgba(255, 255, 255, 0.8);
        padding: 8px 15px;
        border-radius: 20px;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
      }
      .legend-icon {
        width: 40px;
        height: 40px;
        display: flex;
        justify-content: center;
        align-items: center;
        border-radius: 50%;
        overflow: hidden;
        background-color: transparent;
      }
      /* 游戏顶部自适应布局容器 */
      .game-header {
        position: absolute;
        top: 10px;
        left: 10px;
        right: 10px;
        z-index: 100;
        display: grid;
        grid-template-columns: 1fr auto;
        grid-template-areas: "left right";
        gap: 10px;
        align-items: start;
      }
      
      .timer-display, .level-display {
        grid-area: left;
        justify-self: start;
        font-size: clamp(12px, 2vw, 18px);
        font-weight: bold;
        color: white;
        padding: clamp(6px, 1vw, 8px) clamp(12px, 2.5vw, 20px);
        border-radius: 20px;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        background-color: rgba(86, 204, 242, 0.8);
        box-shadow: 0 4px 10px rgba(86, 204, 242, 0.3);
        text-align: left;
        white-space: nowrap;
      }
      
      .level-display .flex {
        white-space: nowrap;
        flex-wrap: nowrap;
      }
      
      .level-objective {
        white-space: nowrap;
        flex-shrink: 0;
      }
      
      .game-controls {
        grid-area: right;
        justify-self: end;
        display: flex;
        gap: clamp(6px, 1vw, 10px);
        align-items: center;
        z-index: 101;
      }
      
      /* 第二行：分数和进度条 */
      .second-row {
        position: absolute;
        top: clamp(60px, 8vh, 80px);
        left: 10px;
        right: 10px;
        z-index: 50;
        display: flex;
        align-items: center;
        gap: 15px;
      }
      
      .second-row .score-display {
        font-size: clamp(14px, 2.5vw, 20px);
        font-weight: bold;
        color: white;
        padding: clamp(6px, 1vw, 8px) clamp(10px, 2vw, 15px);
        border-radius: 20px;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        background-color: rgba(255, 107, 157, 0.8);
        box-shadow: 0 4px 10px rgba(255, 107, 157, 0.3);
        white-space: nowrap;
        flex-shrink: 0;
      }
      
      .progress-container {
        flex: 1;
        height: clamp(12px, 2vh, 15px);
        background-color: rgba(255, 255, 255, 0.5);
        border-radius: 10px;
        overflow: hidden;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      }
      .progress-bar {
        height: 100%;
        background: linear-gradient(90deg, #FF6B9D, #FFD700);
        width: 0%;
        transition: width 0.3s;
      }
      .level-up {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0);
        font-size: 48px;
        font-weight: bold;
        color: white;
        text-shadow: 0 0 15px rgba(255, 215, 0, 0.8);
        z-index: 10;
        transition: transform 0.3s ease-out;
        animation: sparkle 1s ease-in-out infinite;
      }
      .level-up.show {
        transform: translate(-50%, -50%) scale(1);
      }
      .game-over {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 100;
        display: none;
        background-color: rgba(255, 255, 255, 0.8);
        backdrop-filter: blur(5px);
      }
      .game-over.show {
        display: flex;
      }
      .btn {
        padding: 12px 24px;
        font-size: 18px;
        border: none;
        border-radius: 30px;
        cursor: pointer;
        transition: all 0.3s;
        font-weight: bold;
        color: white;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
      }
      .btn-primary {
        background: linear-gradient(135deg, #FF6B9D, #FF8E53);
      }
      .btn-primary:hover {
        transform: translateY(-3px);
        box-shadow: 0 6px 20px rgba(255, 107, 157, 0.4);
      }
      .btn-secondary {
        background: linear-gradient(135deg, #56CCF2, #2F80ED);
      }
      .btn-secondary:hover {
        transform: translateY(-3px);
        box-shadow: 0 6px 20px rgba(86, 204, 242, 0.4);
      }
      .btn-success {
        background: linear-gradient(135deg, #7ED957, #27AE60);
      }
      .btn-success:hover {
        transform: translateY(-3px);
        box-shadow: 0 6px 20px rgba(126, 217, 87, 0.4);
      }
      .btn-warning {
        background: linear-gradient(135deg, #FFD700, #FFA500);
      }
      .btn-warning:hover {
        transform: translateY(-3px);
        box-shadow: 0 6px 20px rgba(255, 215, 0, 0.4);
      }
      .pause-button {
        display: flex;
        align-items: center;
        justify-content: center;
        padding: clamp(6px, 1vw, 8px);
        font-size: clamp(12px, 2vw, 16px);
        border: none;
        border-radius: 50%;
        cursor: pointer;
        transition: all 0.3s;
        color: white;
        background-color: rgba(155, 89, 182, 0.8);
        box-shadow: 0 4px 10px rgba(155, 89, 182, 0.3);
        width: clamp(35px, 6vw, 50px);
        height: clamp(35px, 6vw, 50px);
      }
      .pause-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 15px rgba(155, 89, 182, 0.4);
      }
      .pause-screen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 200;
        display: none;
        background-color: rgba(255, 255, 255, 0.8);
        backdrop-filter: blur(5px);
      }
      .glass-card {
        background-color: rgba(255, 255, 255, 0.8);
        border-radius: 20px;
        padding: 25px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.5);
      }
      .thought-bubble {
        position: relative;
        background-color: rgba(255, 255, 255, 0.9);
        border-radius: 20px;
        padding: 15px 20px;
        margin: 10px 0;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        max-width: 80%;
      }
      .thought-bubble:after {
        content: '';
        position: absolute;
        bottom: 0;
        left: 50%;
        width: 0;
        height: 0;
        border: 20px solid transparent;
        border-top-color: rgba(255, 255, 255, 0.9);
        border-bottom: 0;
        margin-left: -20px;
        margin-bottom: -20px;
      }
      .floating {
        animation: float 3s ease-in-out infinite;
      }
      .sparkling {
        animation: sparkle 2s ease-in-out infinite;
      }
      .bouncing {
        animation: bounce-slow 2s infinite;
      }
      .wiggling {
        animation: wiggle 1s ease-in-out infinite;
      }
      .rainbow-text {
        background: linear-gradient(90deg, #FF6B9D, #FFD700, #7ED957, #56CCF2, #9B59B6);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-size: 400% 400%;
        animation: rainbow 6s ease infinite;
      }
      
      /* 自适应标题样式 */
      .adaptive-title {
        font-size: clamp(1.5rem, 8vw, 3rem);
        line-height: 1.2;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 100%;
      }
      
      .adaptive-subtitle {
        font-size: clamp(0.9rem, 4vw, 1.25rem);
        line-height: 1.3;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 100%;
      }
      
      /* 响应式调整 */
      @media (max-width: 480px) {
        .adaptive-title {
          font-size: clamp(1.2rem, 7vw, 2.5rem);
        }
        .adaptive-subtitle {
          font-size: clamp(0.8rem, 3.5vw, 1.1rem);
        }
      }
      
      @media (max-width: 320px) {
        .adaptive-title {
          font-size: clamp(1rem, 6vw, 2rem);
        }
        .adaptive-subtitle {
          font-size: clamp(0.7rem, 3vw, 1rem);
        }
      }
      @keyframes rainbow {
        0% {background-position: 0% 50%}
        50% {background-position: 100% 50%}
        100% {background-position: 0% 50%}
      }
    }
  </style>
</head>
<body class="overflow-hidden">
  <div class="game-container">
    <!-- 背景图 -->
    <div class="absolute inset-0 z-0">
      <img src="https://p9-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/rc/pc/super_tool/a67b2e5dd00743b2a5122c75e6134e92~tplv-a9rns2rl98-image.image?rcl=2025110216154585177F0BFBDDD877D1A7&rk3s=8e244e95&rrcfp=f06b921b&x-expires=1764663359&x-signature=ijMhZ3vFbBfok%2BeidrkjPwcVLIw%3D" 
           alt="可爱背景" 
           class="w-full h-full object-cover">
    </div>
    
    <!-- 游戏结束弹窗 -->
    <div class="game-complete-popup hidden fixed inset-0 flex items-center justify-center" id="gameCompletePopup" style="z-index: 9999;">
      <div class="absolute inset-0 bg-black bg-opacity-70" style="z-index: 9998;"></div>
      <div class="glass-card max-w-md mx-auto text-center relative p-6" style="z-index: 10000;">
        <div class="flex justify-center mb-4">
          <div class="w-24 h-24 rounded-full bg-gradient-to-r from-blue-400 to-purple-500 flex items-center justify-center">
            <svg class="w-12 h-12 text-white" fill="currentColor" viewBox="0 0 24 24">
              <!-- 天使光环 -->
              <ellipse cx="12" cy="4" rx="6" ry="1.5" fill="gold" opacity="0.8"/>
              <!-- 天使头部 -->
              <circle cx="12" cy="8" r="3" fill="currentColor"/>
              <!-- 天使身体 -->
              <path d="M12 11c-2 0-3.5 1-3.5 2.5v4c0 1 0.5 1.5 1.5 1.5h4c1 0 1.5-0.5 1.5-1.5v-4c0-1.5-1.5-2.5-3.5-2.5z" fill="currentColor"/>
              <!-- 左翅膀 -->
              <path d="M8 13c-2-1-4-0.5-4 1.5s1 3 3 2.5c1-0.25 1.5-1 1-2z" fill="currentColor" opacity="0.9"/>
              <!-- 右翅膀 -->
              <path d="M16 13c2-1 4-0.5 4 1.5s-1 3-3 2.5c-1-0.25-1.5-1-1-2z" fill="currentColor" opacity="0.9"/>
              <!-- 天使眼睛 -->
              <circle cx="10.5" cy="7.5" r="0.5" fill="white"/>
              <circle cx="13.5" cy="7.5" r="0.5" fill="white"/>
            </svg>
          </div>
        </div>
        <h2 class="text-3xl font-bold mb-2 rainbow-text">游戏挑战结束!</h2>
        <h3 class="text-2xl font-bold mb-4 text-yellow-500">恭喜完成所有关卡!</h3>
        <p class="text-xl mb-6">你已经成功完成了所有挑战，展现了出色的理性消费能力！</p>
        <div class="bg-white bg-opacity-80 rounded-lg p-4 mb-6">
          <p class="text-lg font-bold text-green-600">最终节省: <span id="finalSavings" class="text-green-600">5000</span> 元</p>
          <p class="text-gray-600 mt-2">后续正在开发新的关卡，敬请期待！</p>
          <p class="text-gray-600 mt-1">欢迎关注我们的更新！</p>
        </div>
        <button class="btn btn-primary w-full text-xl font-bold py-3 transition-transform hover:scale-105 active:scale-95 cursor-pointer relative" id="gameCompleteButton" style="position: relative; z-index: 10001; cursor: pointer; touch-action: manipulation;">
          <i class="fa fa-home mr-2"></i> 返回主页
        </button>
      </div>
    </div>
    
    <!-- 开始界面 -->
    <div class="start-screen" id="startScreen">
      <div class="glass-card max-w-md mx-auto">
        <h1 class="adaptive-title font-bold mb-6 rainbow-text">双11钱包保卫战</h1>
        
        <div class="flex justify-center mb-6">
          <img src="ts.png" 
               alt="游戏角色" 
               class="w-32 h-32 object-contain floating">
        </div>
        
        <p class="adaptive-subtitle mb-4 text-gray-700">抵制冲动消费，培养理性购物习惯</p>
        
        <div class="thought-bubble mx-auto mb-6">
          <p class="text-gray-800">点击射击<span class="text-pink-500 font-bold">魔鬼般</span>的冲动消费念头，放过<span class="text-green-500 font-bold">天使般</span>的理性消费念头。</p>
        </div>
        
        <!-- 图例说明 -->
        <div class="legend mb-8">
          <div class="legend-item">
            <div class="legend-icon">
              <img src="cd.png" 
                   alt="冲动消费" 
                   class="w-full h-full object-contain">
            </div>
            <span class="text-gray-700">冲动消费（点击）</span>
          </div>
          <div class="legend-item">
            <div class="legend-icon">
              <img src="ts.png" 
                   alt="理性消费" 
                   class="w-full h-full object-contain">
            </div>
            <span class="text-gray-700">理性消费（放过）</span>
          </div>
        </div>
        
        <!-- 开始按钮 -->
        <button id="startGameButton" class="btn btn-primary w-full">
          <svg class="w-5 h-5 mr-2 inline-block" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
            <circle cx="12" cy="12" r="10" fill="currentColor" opacity="0.2"></circle>
            <polygon points="10,8 10,16 16,12" fill="currentColor"></polygon>
          </svg>
          开始游戏
        </button>
        
        <p class="text-sm mt-4 text-gray-600">目标节省：500元（达到目标自动晋级）</p>
      </div>
    </div>
    
    <!-- 游戏画布 -->
    <canvas id="gameCanvas" class="game-canvas absolute inset-0 z-10"></canvas>
    
    <!-- 游戏顶部自适应布局 -->
    <div class="game-header">
      <!-- 左侧：关卡和目标显示 -->
      <div class="level-display" id="levelDisplay">
        <div class="flex items-center">
          <span id="levelNumber">关卡: 1</span>
          <span class="text-white mx-2">•</span>
          <div class="level-objective" id="levelObjective">
            <span class="text-yellow-300 text-sm">目标节省500元</span>
          </div>
        </div>
      </div>
      
      <!-- 右侧：控制按钮 -->
      <div class="game-controls">
        <!-- 音乐开关按钮（使用可切换的内联 SVG） -->
        <div class="pause-button flower-button" id="musicButton">
          <span id="musicIcon" class="text-white" aria-hidden="true">
            <svg class="w-5 h-5" viewBox="0 0 24 24" fill="currentColor">
              <path d="M3 10v4h4l5 4V6l-5 4H3z"></path>
              <path d="M16 8c1.7 1.7 1.7 5.3 0 7" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path>
            </svg>
          </span>
        </div>
        
        <!-- 暂停按钮 -->
        <div class="pause-button flower-button" id="pauseButton">
          <svg class="w-5 h-5 text-white" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
            <rect x="6" y="5" width="4" height="14"></rect>
            <rect x="14" y="5" width="4" height="14"></rect>
          </svg>
        </div>
      </div>
    </div>
    
    <!-- 第二行：分数和进度条 -->
    <div class="second-row">
      <!-- 分数显示 -->
      <div class="score-display" id="scoreDisplay">
        <i class="fa fa-piggy-bank text-white mr-1"></i> 节省: 0元
      </div>
      
      <!-- 进度条 -->
      <div class="progress-container" id="progressContainer">
        <div class="progress-bar" id="progressBar"></div>
      </div>
    </div>
    
    <!-- 升级提示 -->
    <div class="level-up hidden" id="levelUp">
      <i class="fa fa-star"></i> 升级啦! <i class="fa fa-star"></i>
    </div>
    
    <!-- 关卡升级弹窗 -->
    <div class="level-up-popup hidden fixed inset-0 flex items-center justify-center" id="levelUpPopup" style="z-index: 9999;">
      <div class="absolute inset-0 bg-black bg-opacity-70" style="z-index: 9998;"></div>
      <div class="glass-card max-w-md mx-auto text-center relative p-6" style="z-index: 10000;">
        <div class="flex justify-center mb-4">
          <div class="w-24 h-24 rounded-full bg-gradient-to-r from-pink-500 to-purple-600 flex items-center justify-center">
            <i class="fa fa-trophy text-white text-4xl"></i>
          </div>
        </div>
        <h2 class="text-3xl font-bold mb-2 rainbow-text">恭喜升级!</h2>
        <h3 class="text-2xl font-bold mb-4 text-pink-500">第 <span id="newLevelNumber">2</span> 关</h3>
        <p class="text-xl mb-6" id="levelUpMessage">你成功抵制了冲动消费，太棒了！</p>
        <div class="bg-white bg-opacity-80 rounded-lg p-4 mb-6">
          <p class="text-lg font-bold">新目标:节省 <span id="newTargetScore" class="text-green-600">600</span> 元</p>
          <p class="text-gray-600 mt-2" id="levelUpHint">难度增加了，加油！</p>
        </div>
        <button class="btn btn-primary w-full text-xl font-bold py-3 transition-transform hover:scale-105 active:scale-95 cursor-pointer relative" id="continueButton" style="position: relative; z-index: 10001; cursor: pointer; touch-action: manipulation;">
          <i class="fa fa-arrow-right mr-2"></i> 点击继续挑战
        </button>
      </div>
    </div>
    
    <!-- 暂停界面 -->
    <div class="pause-screen" id="pauseScreen">
      <div class="glass-card max-w-md mx-auto text-center">
        <h2 class="text-3xl font-bold mb-6 rainbow-text">游戏暂停</h2>
        
        <div class="flex flex-col gap-4">
          <button class="btn btn-success" id="resumeButton">
            <svg class="w-5 h-5 mr-2 inline-block" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
              <polygon points="9,7 9,17 17,12"></polygon>
            </svg>
            继续游戏
          </button>
          <button class="btn btn-warning" id="pauseRestartButton">
            <svg class="w-5 h-5 mr-2 inline-block" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
              <path d="M12 6V3l-4 4 4 4V8c2.8 0 5 2.2 5 5s-2.2 5-5 5-5-2.2-5-5H5c0 3.9 3.1 7 7 7s7-3.1 7-7-3.1-7-7-7z"></path>
            </svg>
            重新开始
          </button>
          <button class="btn btn-primary" id="quitButton">
            <svg class="w-5 h-5 mr-2 inline-block" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
              <path d="M3 11l9-7 9 7v9a2 2 0 0 1-2 2h-4a2 2 0 0 1-2-2v-4H9v4a2 2 0 0 1-2 2H3z"></path>
            </svg>
            返回主页
          </button>
        </div>
      </div>
    </div>
    
    <!-- 游戏结束界面 -->
    <div class="game-over" id="gameOverScreen">
      <div class="glass-card max-w-md mx-auto text-center">
        <h2 class="text-3xl font-bold mb-4 rainbow-text">游戏结束</h2>
        
        <div class="flex justify-center mb-6">
          <img src="background.jpeg" 
               alt="游戏结束" 
               class="w-32 h-32 object-contain bouncing">
        </div>
        
        <p class="text-2xl mb-2 text-gray-700">最终节省: <span id="finalScore" class="text-pink-500 font-bold">0</span>元</p>
        <p class="text-xl mb-6" id="scoreStatus">再接再厉!</p>
        
        <button class="btn btn-primary" id="restartButton">
          <svg class="w-5 h-5 mr-2 inline-block" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
            <path d="M12 6V3l-4 4 4 4V8c2.8 0 5 2.2 5 5s-2.2 5-5 5-5-2.2-5-5H5c0 3.9 3.1 7 7 7s7-3.1 7-7-3.1-7-7-7z"></path>
          </svg>
          再来一次
        </button>
      </div>
    </div>
    </div>
  </div>

  <!-- 版权信息 -->
  <div id="copyrightBar" class="fixed bottom-0 left-0 right-0 z-30 bg-gray-800 bg-opacity-90">
    <p class="text-white text-xs text-center py-2 px-4">
      © wise11.mumulife.net 版权所有
    </p>
  </div>

  <script>
    // 游戏元素
    let canvas, ctx;
    let startScreen, scoreDisplay, levelDisplay, progressContainer, progressBar, levelUpElement, gameOverScreen, levelUpPopup, gameCompletePopup;
    let finalScoreElement, scoreStatusElement, restartButton, pauseButton, pauseScreen, resumeButton, pauseRestartButton, quitButton, continueButton, gameCompleteButton, finalSavingsElement;
    let newLevelNumberElement, newTargetScoreElement, levelUpMessageElement, levelUpHintElement;
    let musicButton, musicIcon;
    
    // 玩家
    let player = {
      x: 0,
      y: 0,
      width: 60,
      height: 60,
      speed: 15
    };
    
    // 游戏元素
    let bullets = [];
    let thoughts = [];
    let hitEffects = [];
    let collectibles = [];
    let hitTexts = []; // 存储击中时的对话文本
    
    // 对象池 - 减少垃圾回收
    let bulletPool = [];
    let thoughtPool = [];
    let effectPool = [];
    
    // 对象池管理
    function getBulletFromPool() {
      return bulletPool.length > 0 ? bulletPool.pop() : {};
    }
    
    function returnBulletToPool(bullet) {
      if (bulletPool.length < 50) { // 限制池大小
        bulletPool.push(bullet);
      }
    }
    
    function getThoughtFromPool() {
      return thoughtPool.length > 0 ? thoughtPool.pop() : {};
    }
    
    function returnThoughtToPool(thought) {
      if (thoughtPool.length < 30) { // 限制池大小
        thoughtPool.push(thought);
      }
    }
    
    function getEffectFromPool() {
      return effectPool.length > 0 ? effectPool.pop() : {};
    }
    
    function returnEffectToPool(effect) {
      if (effectPool.length < 20) { // 限制池大小
        effectPool.push(effect);
      }
    }
    
    // 控制状态
    let movingLeft = false;
    let movingRight = false;
    let gameLoopRunning = false;
    
    // 音效
    const shootSound = new Audio('music/shoot.mp3'); // 射击音效
    const hitImpulseSound = new Audio('music/hit_impulse.mp3'); // 击中冲动消费音效
    const hitRationalSound = new Audio('music/hit_rational.mp3'); // 击中理性消费音效
    const collectSound = new Audio('music/collect.mp3'); // 收集物品音效
    const levelUpSound = new Audio('music/levelup.mp3'); // 升级音效
    const gameOverSound = new Audio('music/gameover.mp3'); // 游戏结束音效
    const pauseSound = new Audio('music/pause.mp3'); // 暂停音效
    const victorySound = new Audio('music/过关鼓掌.m4a'); // 胜利音效
    
    // 背景音乐 - 每一关不同的音乐，提供多种格式以提高兼容性
    const backgroundMusic = {};
    
    // 创建音频对象的辅助函数，避免重复加载
    function createAudioWithFallback(primarySrc, fallbackSrc) {
      try {
        // 首先检测浏览器是否支持该格式
        const audio = new Audio();
        const canPlay = audio.canPlayType('audio/mp4') || audio.canPlayType('audio/m4a');
        
        if (canPlay && primarySrc.includes('.m4a')) {
          return new Audio(primarySrc);
        } else {
          return new Audio(fallbackSrc);
        }
      } catch (error) {
        console.log('音频创建失败，使用备用格式:', error);
        return new Audio(fallbackSrc);
      }
    }
    
    // 初始化背景音乐（禁用预加载，避免非当前曲目产生网络请求被中途终止的日志）
    backgroundMusic.level1 = new Audio('music/bgm05.mp3');   // 第一关：轻松愉快 (使用mp3格式，兼容性最好)
    backgroundMusic.level2 = createAudioWithFallback('music/bgm3.m4a', 'music/bgm05.mp3');   // 第二关
    backgroundMusic.level3 = createAudioWithFallback('music/bgm01_1.m4a', 'music/bgm05.mp3'); // 第三关
    // 禁止预加载，只有在真正播放时才发起网络请求
    Object.values(backgroundMusic).forEach(music => { try { music.preload = 'none'; } catch(_){} });
    
    // 设置背景音乐循环播放和音量
    Object.values(backgroundMusic).forEach(music => {
      music.loop = true;
      music.volume = 0.3; // 设置较低音量，不干扰游戏音效
      
      // 添加错误处理，避免加载失败
      music.addEventListener('error', (e) => {
        console.log('背景音乐加载失败:', music.src, e);
      });
      
      // 添加加载完成事件
      music.addEventListener('canplaythrough', () => {
        console.log('背景音乐加载完成:', music.src);
      });
    });
    
    // 音乐控制状态
    let musicEnabled = true;
    let currentBackgroundMusic = null;
    
    // 性能优化设置
    let performanceMode = false; // 性能模式开关
    let isMobileDevice = false;  // 移动设备检测
    let isSafari = false;        // Safari浏览器检测
    let lastFrameTime = 0;       // 上一帧时间
    let targetFPS = 60;          // 目标帧率
    let frameInterval = 1000 / targetFPS; // 帧间隔
    
    // 检测移动设备和浏览器类型
    function detectMobileDevice() {
      const userAgent = navigator.userAgent.toLowerCase();
      const mobileKeywords = ['mobile', 'android', 'iphone', 'ipad', 'ipod', 'blackberry', 'windows phone'];
      isMobileDevice = mobileKeywords.some(keyword => userAgent.includes(keyword));
      
      // 检测Safari浏览器（包括移动端Safari）
      isSafari = /safari/.test(userAgent) && !/chrome/.test(userAgent) && !/chromium/.test(userAgent);
      
      // 检测微信浏览器
      const isWechat = /micromessenger/.test(userAgent);
      
      console.log('设备检测结果:', {
        isMobileDevice: isMobileDevice,
        isSafari: isSafari,
        isWechat: isWechat,
        userAgent: userAgent
      });
      
      // 为body添加相应的CSS类
      if (isMobileDevice) {
        document.body.classList.add('mobile-device');
        
        if (isWechat) {
          document.body.classList.add('wechat-browser');
          console.log('检测到微信浏览器');
        } else if (isSafari) {
          document.body.classList.add('safari-mobile');
          console.log('检测到Safari移动端');
        }
      }
      
      // 移动设备保持与PC相同的帧率，确保游戏速度一致
      if (isMobileDevice) {
        performanceMode = false; // 不启用性能模式，保持60FPS
        targetFPS = 60; // 保持与PC相同的帧率
        frameInterval = 1000 / targetFPS;
        console.log('检测到移动设备，保持60FPS以确保游戏速度一致');
      }
      
      // 移动端优化处理
      if (isMobileDevice) {
        optimizeMobileExperience();
      }
    }
    
    // 移动端体验优化 - 简化版本
    function optimizeMobileExperience() {
      console.log('启动移动端体验优化');
      
      // 阻止页面缩放（仅在必要时）
      document.addEventListener('touchstart', function(event) {
        if (event.touches.length > 1) {
          event.preventDefault();
        }
      }, { passive: false });
      
      // 阻止双击缩放（温和处理）
      let lastTouchEnd = 0;
      document.addEventListener('touchend', function(event) {
        const now = (new Date()).getTime();
        if (now - lastTouchEnd <= 300) {
          event.preventDefault();
        }
        lastTouchEnd = now;
      }, { passive: false });
      
      // 监听方向改变（简化处理）
      window.addEventListener('orientationchange', function() {
        setTimeout(() => {
          if (typeof resizeCanvas === 'function') {
            resizeCanvas();
          }
        }, 500); // 增加延迟，确保浏览器完成方向改变
      });
      
      // 微信浏览器特殊处理
      if (isWechat) {
        console.log('应用微信浏览器特殊优化');
        // 微信浏览器中避免过度的事件阻止
        document.addEventListener('touchmove', function(event) {
          // 只在游戏画布区域阻止滚动
          if (event.target === canvas || canvas.contains(event.target)) {
            event.preventDefault();
          }
        }, { passive: false });
      }
    }
    
    // 图片资源（为兼容Safari，先绑定事件再设置src）
    const backgroundImage = new Image();
    backgroundImage.onload = imageLoaded;
    backgroundImage.onerror = function() { console.log('Failed to load background image'); };
    backgroundImage.src = 'game_background.png'; // 可爱背景图
    
    const impulseImage = new Image();
    impulseImage.onload = imageLoaded;
    impulseImage.onerror = function() { console.log('Failed to load impulse image'); };
    impulseImage.src = 'cd.png'; // 本地 CD 图标替代恶魔图标
    
    const rationalImage = new Image();
    rationalImage.onload = imageLoaded;
    rationalImage.onerror = function() { console.log('Failed to load rational image'); };
    rationalImage.src = 'ts.png'; // 本地 TS 图标替代天使图标
    
    const coinImage = new Image();
    coinImage.onload = imageLoaded;
    coinImage.onerror = function() { console.log('Failed to load coin image'); };
    coinImage.src = 'jb.png'; // 本地金币图标
    
    // 发射器图片（Safari兼容: 绑定事件→设置src→尝试decode）
    const launcherImage = new Image();
    launcherImage.crossOrigin = 'anonymous';
    launcherImage.onload = imageLoaded;
    launcherImage.onerror = function(e) { console.log('Failed to load launcher image', e); };
    launcherImage.src = 'sj.png'; // 射击装置图标
    try {
      // 尝试明确解码，提升Safari渲染稳定性
      if (launcherImage.decode) {
        launcherImage.decode().then(() => {
          console.log('Launcher image decoded successfully');
        }).catch(err => {
          console.log('Launcher image decode failed:', err);
        });
      }
    } catch (e) {
      console.log('Launcher image decode not supported:', e);
    }
    
    // 图片加载完成标志
    let imagesLoaded = 0;
    const totalImages = 5; // 背景图、冲动消费图、理性消费图、金币图、发射器图
    
    // 检查所有图片是否加载完成
    function imageLoaded() {
      imagesLoaded++;
      console.log(`Image loaded: ${imagesLoaded}/${totalImages}`);
      
      if (imagesLoaded === totalImages) {
        console.log('All images loaded successfully!');
      }
    }
    
    // 事件已在创建阶段绑定（兼容Safari），此处不再重复绑定
    
    // 游戏状态
    let gameState = {
      difficulty: 'easy',
      score: 0,
      gameOver: false,
      paused: false,
      spawnTimer: 0,
      spawnInterval: 1000,
      spawnIntervalDecrease: 50,
      targetScore: 500, // 第一关目标分数
      level: 1,
      thoughtsSpawned: 0,
      thoughtsPerLevel: 20,
      // 关卡特定属性
      impulsePenalty: 10, // 冲动消费扣分数
      rationalBonus: 20,  // 理性消费得分
      baseThoughtSpeed: 2.0 // 念头基础速度
    };
    
    // 全局函数定义 - 移到init函数外以确保全局可访问
    
    // 显示游戏结束弹窗
    function showGameCompletePopup() {
      console.log('显示游戏结束弹窗');
      // 暂停游戏
      gameState.paused = true;
      
      // 停止背景音乐
      stopBackgroundMusic();
      
      // 移动端音频解锁（如果需要）
      if (isMobileDevice && mobileAudioUnlocker && !mobileAudioUnlocked) {
        console.log('游戏完成时尝试解锁移动端音频');
        try {
          mobileAudioUnlocker();
        } catch (error) {
          console.log('游戏完成时音频解锁失败:', error);
        }
      }

      // 播放胜利音效
      try {
        if (victorySound) {
          console.log('尝试播放胜利音效');
          victorySound.currentTime = 0;
          
          // 移动端需要额外处理
          if (isMobileDevice) {
            // 确保音量设置正确
            victorySound.volume = 0.7;
            
            // 添加更多的错误处理和重试机制
            const playVictorySound = () => {
              const playPromise = victorySound.play();
              if (playPromise !== undefined) {
                playPromise.then(() => {
                  console.log('胜利音效播放成功');
                }).catch(e => {
                  console.log('胜利音效播放失败:', e);
                  // 如果是移动端自动播放被阻止，尝试在下次用户交互时播放
                  if (e.name === 'NotAllowedError') {
                    console.log('移动端音频播放被阻止，等待用户交互');
                    const playOnTouch = () => {
                      victorySound.play().catch(err => console.log('用户交互后音频播放仍失败:', err));
                      document.removeEventListener('touchstart', playOnTouch);
                      document.removeEventListener('click', playOnTouch);
                    };
                    document.addEventListener('touchstart', playOnTouch, { once: true });
                    document.addEventListener('click', playOnTouch, { once: true });
                  }
                });
              }
            };
            
            // 稍微延迟播放，确保音频上下文已准备好
            setTimeout(playVictorySound, 100);
          } else {
            // 桌面端直接播放
            victorySound.play().catch(e => console.log('Error playing victory sound:', e));
          }
        }
      } catch (error) {
        console.log('Error playing victory sound:', error);
      }

      // 播放通关成功背景音乐（使用第一关的背景音乐作为庆祝音乐）
      setTimeout(() => {
        if (musicEnabled) {
          console.log('播放通关成功背景音乐');
          playBackgroundMusic(1); // 使用第一关的音乐作为庆祝音乐
        }
      }, 500); // 延迟500ms播放，让胜利音效先播放
      
      // 更新最终节省金额
      finalSavingsElement.textContent = gameState.score;
      // 显示弹窗
      gameCompletePopup.classList.remove('hidden');
    }
    
    // 音乐控制函数
    function playBackgroundMusic(level) {
      if (!musicEnabled) {
        console.log('音乐已禁用，跳过播放');
        return;
      }
      
      // 根据关卡选择音乐
      let musicKey = `level${level}`;
      if (backgroundMusic[musicKey]) {
        let targetMusic = backgroundMusic[musicKey];
        
        // 防止重复播放：如果当前音乐已经在播放且是同一首，直接返回
        if (currentBackgroundMusic === targetMusic && 
            !currentBackgroundMusic.paused && 
            currentBackgroundMusic.currentTime > 0) {
          console.log(`Level ${level} music is already playing, skipping duplicate play`);
          return;
        }
        
        // 停止当前播放的音乐（强力停止所有音频）
        console.log(`准备播放关卡 ${level} 的背景音乐`);
        stopBackgroundMusic();
        
        currentBackgroundMusic = targetMusic;
        
        // 添加音频加载事件监听（只添加一次）
        if (!currentBackgroundMusic.hasAttribute('data-listeners-added')) {
          currentBackgroundMusic.addEventListener('canplaythrough', function() {
            console.log(`Level ${level} music loaded successfully`);
          });
          
          currentBackgroundMusic.addEventListener('error', function(e) {
            console.log(`Error loading level ${level} music:`, e);
            // 如果音频加载失败，不要禁用所有音乐，只是跳过这个文件
            console.log('音频文件加载失败，但保持音乐功能开启');
          });
          
          currentBackgroundMusic.setAttribute('data-listeners-added', 'true');
        }
        
        try {
          currentBackgroundMusic.currentTime = 0;
          
          // 移动端特殊处理
          if (isMobileDevice) {
            // 如果音频已经解锁，直接播放
            if (mobileAudioUnlocked) {
              console.log(`移动端音频已解锁，直接播放关卡 ${level} 背景音乐`);
              const playPromise = currentBackgroundMusic.play();
              if (playPromise !== undefined) {
                playPromise.then(() => {
                  console.log(`Level ${level} music started playing on mobile`);
                }).catch(e => {
                  console.log('移动端背景音乐播放失败:', e);
                });
              }
            } else {
              // 移动端需要用户交互后才能播放，先不播放
              console.log(`移动端检测到，标记关卡 ${level} 背景音乐为待播放状态`);
              // 将音乐标记为待播放状态
              currentBackgroundMusic.setAttribute('data-pending-play', 'true');
            }
            return;
          }
          
          // 桌面端直接播放
          console.log(`桌面端直接播放关卡 ${level} 背景音乐`);
          const playPromise = currentBackgroundMusic.play();
          if (playPromise !== undefined) {
            playPromise.then(() => {
              console.log(`Level ${level} music started playing on desktop`);
            }).catch(e => {
              console.log('Error playing background music:', e);
              // 如果自动播放被阻止，标记为待播放
              if (e.name === 'NotAllowedError') {
                console.log('音频自动播放被浏览器阻止，等待用户交互');
                currentBackgroundMusic.setAttribute('data-pending-play', 'true');
              }
            });
          }
        } catch (error) {
          console.log('Error playing background music:', error);
        }
      } else {
        console.log(`关卡 ${level} 的背景音乐不存在`);
      }
    }
    
    function stopBackgroundMusic() {
      // 强力停止所有背景音乐，防止多个音频同时播放
      Object.values(backgroundMusic).forEach(music => {
        try {
          if (!music.paused) {
            music.pause();
            music.currentTime = 0;
            console.log('停止背景音乐:', music.src);
          }
        } catch (error) {
          console.log('停止背景音乐时出错:', music.src, error);
        }
      });
      
      // 清除当前背景音乐引用
      if (currentBackgroundMusic) {
        try {
          currentBackgroundMusic.pause();
          currentBackgroundMusic.currentTime = 0;
        } catch (error) {
          console.log('Error stopping current background music:', error);
        }
        currentBackgroundMusic = null;
      }
    }
    
    function toggleMusic() {
      musicEnabled = !musicEnabled;
      
      if (musicEnabled) {
        // 开启音乐：切换为音量开启图标
        if (musicIcon) {
          musicIcon.innerHTML = `
            <svg class="w-5 h-5" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
              <path d="M3 10v4h4l5 4V6l-5 4H3z"></path>
              <path d="M16 8c1.7 1.7 1.7 5.3 0 7" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path>
            </svg>`;
        }
        // 如果游戏正在进行，播放对应关卡的音乐
        if (!gameState.gameOver && !gameState.paused) {
          playBackgroundMusic(gameState.level);
        }
      } else {
        // 关闭音乐：切换为静音图标
        if (musicIcon) {
          musicIcon.innerHTML = `
            <svg class="w-5 h-5" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
              <path d="M3 10v4h4l5 4V6l-5 4H3z"></path>
              <path d="M16 8c1.7 1.7 1.7 5.3 0 7" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" opacity="0.3"></path>
              <line x1="18" y1="6" x2="22" y2="10" stroke="currentColor" stroke-width="2"/>
              <line x1="22" y1="6" x2="18" y2="10" stroke="currentColor" stroke-width="2"/>
            </svg>`;
        }
        stopBackgroundMusic();
      }
      
      // 用户交互后，尝试启用音频上下文
      try {
        if (currentBackgroundMusic && currentBackgroundMusic.paused && musicEnabled) {
          currentBackgroundMusic.play().catch(e => {
            console.log('音频播放需要用户交互:', e);
          });
        }
      } catch (error) {
        console.log('音频播放错误:', error);
      }
    }
    
    // 移动端音频解锁状态
    let mobileAudioUnlocked = false;
    
    // 移动端音频启用函数
    function enableMobileAudio() {
      console.log('启用移动端音频支持');
      
      // 创建一个静音的音频播放来解锁音频上下文
      const unlockAudio = () => {
        if (mobileAudioUnlocked) return; // 避免重复解锁
        
        try {
          console.log('开始解锁移动端音频...');
          
          // 使用一个短音效解锁音频上下文，避免同时触发多首背景音乐的网络请求
          if (shootSound && shootSound.paused) {
            shootSound.volume = 0; // 静音播放
            const playPromise = shootSound.play();
            if (playPromise !== undefined) {
              playPromise.then(() => {
                shootSound.pause();
                shootSound.currentTime = 0;
                shootSound.volume = 0.5; // 恢复正常音量
                console.log('短音效已用于解锁音频');
              }).catch(e => {
                console.log('短音效解锁失败:', e);
              });
            }
          }
          
          // 解锁所有音效，但排除游戏结束和胜利音效（避免在游戏开始时播放）
          const soundEffects = [shootSound, hitImpulseSound, hitRationalSound, collectSound, levelUpSound, pauseSound];
          soundEffects.forEach((sound, index) => {
            if (sound && sound.paused) {
              sound.volume = 0;
              const playPromise = sound.play();
              if (playPromise !== undefined) {
                playPromise.then(() => {
                  sound.pause();
                  sound.currentTime = 0;
                  sound.volume = 0.5; // 恢复正常音量
                  console.log(`音效 ${index + 1} 已解锁`);
                }).catch(e => {
                  console.log(`音效 ${index + 1} 解锁失败:`, e);
                });
              }
            }
          });
          
          // 单独处理胜利音效和游戏结束音效，只设置音量不播放
          if (victorySound) {
            victorySound.volume = 0.7;
            console.log('胜利音效已准备就绪');
          }
          if (gameOverSound) {
            gameOverSound.volume = 0.5;
            console.log('游戏结束音效已准备就绪');
          }
          
          mobileAudioUnlocked = true;
          console.log('移动端音频解锁完成');
          
          // 不再批量触发背景音乐，保持干净的网络面板
          
          // 解锁后，处理背景音乐播放（确保只播放一个）
          let shouldPlayMusic = false;
          let targetLevel = gameState.level;
          
          // 检查游戏状态，决定是否需要播放背景音乐
          if (musicEnabled && !gameState.gameOver && !gameState.paused) {
            shouldPlayMusic = true;
            console.log('游戏进行中，需要播放当前关卡背景音乐');
          }
          
          // 统一播放逻辑，避免重复播放
          if (shouldPlayMusic && musicEnabled) {
            // 先停止所有背景音乐，然后播放指定关卡的音乐
            stopBackgroundMusic();
            console.log('音频解锁后，播放关卡', targetLevel, '的背景音乐');
            playBackgroundMusic(targetLevel);
          }
          
        } catch (error) {
          console.log('移动端音频解锁过程出错:', error);
        }
      };
      
      // 在用户首次交互时解锁音频
      const firstInteraction = () => {
        unlockAudio();
        // 移除事件监听器，只需要执行一次
        document.removeEventListener('touchstart', firstInteraction);
        document.removeEventListener('click', firstInteraction);
        document.removeEventListener('keydown', firstInteraction);
      };
      
      // 添加事件监听器
      document.addEventListener('touchstart', firstInteraction, { once: true });
      document.addEventListener('click', firstInteraction, { once: true });
      document.addEventListener('keydown', firstInteraction, { once: true });
      
      // 返回解锁函数，供其他地方调用
      return unlockAudio;
    }

    // 关卡目标定义
    const levelObjectives = {
      1: "节省500元",
      2: "节省1500元 (挑战升级)",
      3: "节省5000元 (终极挑战)"
    };
    
    // 更新关卡显示函数
    function updateLevelDisplay() {
      const levelNumberElement = document.getElementById('levelNumber');
      const levelObjectiveElement = document.getElementById('levelObjective');
      
      if (levelNumberElement) {
        levelNumberElement.textContent = `关卡: ${gameState.level}`;
      }
      
      if (levelObjectiveElement) {
        const objective = levelObjectives[gameState.level] || `节省${gameState.targetScore}元`;
        levelObjectiveElement.innerHTML = `<span class="text-yellow-300 text-sm">目标: ${objective}</span>`;
      }
    }
    
    // 返回主页
    function returnToHome() {
      console.log('返回主页');
      // 停止当前背景音乐
      stopBackgroundMusic();
      
      // 停止胜利音效（如果正在播放）
      if (victorySound && !victorySound.paused) {
        victorySound.pause();
        victorySound.currentTime = 0;
        console.log('停止胜利音效');
      }
      
      // 隐藏游戏结束弹窗
      gameCompletePopup.classList.add('hidden');
      // 隐藏游戏界面
      gameCanvas.classList.add('hidden');
      scoreDisplay.classList.add('hidden');
      levelDisplay.classList.add('hidden');
      progressContainer.classList.add('hidden');
      pauseButton.classList.add('hidden');
      musicButton.classList.add('hidden');
      // 显示开始界面
      startScreen.classList.remove('hidden');
      // 重置游戏状态
      gameState.gameOver = true;
      gameState.paused = false;
      // 重置游戏循环状态，确保下次可以正常启动游戏
      gameLoopRunning = false;
      
      console.log('已返回主界面，所有音频已停止');
    }
    
    // 初始化游戏
    function init() {
      console.log('Initializing game...');
      
      // 获取DOM元素
      canvas = document.getElementById('gameCanvas');
      ctx = canvas.getContext('2d');
      startScreen = document.getElementById('startScreen');
      scoreDisplay = document.getElementById('scoreDisplay');
      levelDisplay = document.getElementById('levelDisplay');
      progressContainer = document.getElementById('progressContainer');
      progressBar = document.getElementById('progressBar');
      levelUpElement = document.getElementById('levelUp');
      gameOverScreen = document.getElementById('gameOverScreen');
      levelUpPopup = document.getElementById('levelUpPopup');
      gameCompletePopup = document.getElementById('gameCompletePopup');
      gameCompleteButton = document.getElementById('gameCompleteButton');
      finalSavingsElement = document.getElementById('finalSavings');
      finalScoreElement = document.getElementById('finalScore');
      scoreStatusElement = document.getElementById('scoreStatus');
      restartButton = document.getElementById('restartButton');
      pauseButton = document.getElementById('pauseButton');
      musicButton = document.getElementById('musicButton');
      musicIcon = document.getElementById('musicIcon');
      pauseScreen = document.getElementById('pauseScreen');
      resumeButton = document.getElementById('resumeButton');
      pauseRestartButton = document.getElementById('pauseRestartButton');
      quitButton = document.getElementById('quitButton');
      continueButton = document.getElementById('continueButton');
      newLevelNumberElement = document.getElementById('newLevelNumber');
      newTargetScoreElement = document.getElementById('newTargetScore');
      levelUpMessageElement = document.getElementById('levelUpMessage');
      levelUpHintElement = document.getElementById('levelUpHint');
      
      // 设置画布尺寸为窗口大小
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);
      
      // 初始化玩家
      player = {
        width: 60,
        height: 60,
        speed: 15
      };
      
      // 设置玩家位置（在定义宽高之后）
      player.x = canvas.width / 2 - player.width / 2;
      // 计算并夹取Y坐标，避免在Safari等设备上超出画布，并保持在版权条之上
      {
        const copyrightTop = getCopyrightTopInCanvas();
        const bottomMargin = 30;
        let desiredY = canvas.height - player.height - bottomMargin; // 基础底部边距
        if (Number.isFinite(copyrightTop)) {
          // 发射器底边不得低于版权条顶边
          desiredY = Math.min(desiredY, Math.floor(copyrightTop - player.height - 4));
        }
        player.y = Math.max(0, Math.min(canvas.height - player.height, desiredY));
      }
      
      // 添加事件监听器
      document.addEventListener('keydown', handleKeyDown);
      document.addEventListener('keyup', handleKeyUp);
      canvas.addEventListener('click', handleCanvasClick);
      canvas.addEventListener('mousemove', handleMouseMove);
      canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
      canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
      canvas.addEventListener('touchend', handleTouchEnd);
      
      // 开始按钮事件
      const startGameButton = document.getElementById('startGameButton');
      startGameButton.addEventListener('click', () => {
        // 移动端在用户点击开始游戏时立即尝试解锁音频
        if (isMobileDevice && !mobileAudioUnlocked) {
          console.log('用户点击开始游戏，立即解锁移动端音频');
          try {
            // 立即尝试解锁音频
            if (mobileAudioUnlocker) {
              mobileAudioUnlocker();
            } else {
              // 如果还没有解锁函数，创建一个临时的
              const tempUnlocker = enableMobileAudio();
              if (tempUnlocker) tempUnlocker();
            }
          } catch (error) {
            console.log('开始游戏时音频解锁失败:', error);
          }
        }
        
        // 稍微延迟启动游戏，确保音频解锁有时间完成
        setTimeout(() => {
          startGame('easy');
        }, isMobileDevice ? 200 : 0);
      });
      
      // 重启按钮事件
      restartButton.addEventListener('click', () => {
        gameOverScreen.classList.remove('show');
        startGame('easy');
      });
      
      // 暂停按钮事件
      pauseButton.addEventListener('click', pauseGame);
      
      // 音乐开关按钮事件
      musicButton.addEventListener('click', toggleMusic);
      
      // 继续按钮事件
      resumeButton.addEventListener('click', resumeGame);
      
      // 暂停界面重新开始按钮事件
      pauseRestartButton.addEventListener('click', () => {
        const currentDifficulty = gameState.difficulty;
        pauseScreen.style.display = 'none';
        startGame(currentDifficulty);
      });
      
      // 退出按钮事件
      quitButton.addEventListener('click', () => {
        gameOverScreen.classList.remove('show');
        pauseScreen.style.display = 'none';
        gameCanvas.classList.add('hidden');
        scoreDisplay.classList.add('hidden');
        progressContainer.classList.add('hidden');
        pauseButton.classList.add('hidden');
        startScreen.classList.remove('hidden');
      });
      
      // 简化的继续游戏函数
      function continueGame() {
        console.log('继续游戏函数被调用');
        // 隐藏弹窗
        levelUpPopup.classList.add('hidden');
        // 恢复游戏
        gameState.paused = false;
        // 重置生成计时器
        gameState.spawnTimer = gameState.spawnInterval;
        // 更新玩家速度
        player.speed = 15 + (gameState.level - 1) * 0.5;
        // 更新进度条
        updateProgressBar();
        // 强制刷新游戏循环
        requestAnimationFrame(gameLoop);
      }
      
      // 为按钮添加点击事件
      continueButton.onclick = function(e) {
        console.log('继续按钮被点击了');
        // 防止事件冒泡
        e.stopPropagation();
        // 继续游戏
        continueGame();
      };
      
      // 为整个弹窗卡片添加点击事件，防止点击卡片内容时关闭弹窗
      const popupCard = levelUpPopup.querySelector('.glass-card');
      if (popupCard) {
        popupCard.onclick = function(e) {
          // 防止事件冒泡到弹窗背景
          e.stopPropagation();
        };
      }
      
      // 为弹窗背景添加点击事件，点击背景区域能继续游戏
      levelUpPopup.onclick = function() {
        continueGame();
      };
      
      // 游戏结束按钮事件
      gameCompleteButton.onclick = function(e) {
        console.log('游戏结束按钮被点击了');
        e.stopPropagation();
        // 返回主页
        returnToHome();
      };
      
      // 为游戏结束弹窗卡片添加点击事件，防止点击卡片内容时关闭弹窗
      const gameCompleteCard = gameCompletePopup.querySelector('.glass-card');
      if (gameCompleteCard) {
        gameCompleteCard.onclick = function(e) {
          e.stopPropagation();
        };
      }
      
      // 添加键盘支持 - 统一处理所有关闭弹窗的按键
      document.addEventListener('keydown', function(e) {
        // 只有当弹窗显示时才处理这些按键
        if (!levelUpPopup.classList.contains('hidden')) {
          if (e.key === 'Enter' || e.key === ' ' || e.key === 'Escape') {
            continueGame();
            // 阻止默认行为，防止空格键滚动页面
            e.preventDefault();
          }
        }
      });
      
      // 初始时隐藏游戏界面元素
      gameCanvas.classList.add('hidden');
      scoreDisplay.classList.add('hidden');
      progressContainer.classList.add('hidden');
      pauseButton.classList.add('hidden');
      musicButton.classList.add('hidden');
      levelUpElement.classList.add('hidden');
      
      // 检测移动设备并启用性能优化
      detectMobileDevice();
      
      console.log('Game initialized successfully!');
    }

    // 计算版权条顶部在画布坐标系中的Y值
    function getCopyrightTopInCanvas() {
      try {
        const bar = document.getElementById('copyrightBar');
        if (!bar || !canvas) return Number.POSITIVE_INFINITY; // 不存在则不限制
        const barRect = bar.getBoundingClientRect();
        const canvasRect = canvas.getBoundingClientRect();
        // 将DOM像素坐标转换到画布坐标系（同单位，直接相减即可）
        const topInCanvas = barRect.top - canvasRect.top;
        return topInCanvas;
      } catch (e) {
        console.log('Failed to compute copyright top:', e);
        return Number.POSITIVE_INFINITY;
      }
    }

    // 调整画布尺寸
    function resizeCanvas() {
      const container = document.querySelector('.game-container');
      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;
      
      // 针对不同浏览器设置不同的最小高度
      let minHeight = 500;
      if (isSafari && isMobileDevice) {
        // Safari移动端需要更大的最小高度，确保发射器可见
        minHeight = 600;
        console.log('Safari移动端：设置最小高度为', minHeight);
      } else if (isMobileDevice) {
        // 其他移动设备保持原有设置
        minHeight = 500;
      }
      
      // 确保画布有足够的高度
      if (canvas.height < minHeight) {
        canvas.height = minHeight;
        console.log('画布高度调整为最小高度:', minHeight);
      }
      
      // 更新玩家位置，确保发射器在屏幕底部可见，且在版权条之上
      if (player) {
        player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));
        
        // 针对不同浏览器设置不同的底部边距
        let bottomMargin = 30; // 默认边距
        if (isSafari && isMobileDevice) {
          // Safari移动端适度底部边距，避免越界
          bottomMargin = 50;
          console.log('Safari移动端：设置底部边距为', bottomMargin);
        } else if (isMobileDevice) {
          // 其他移动设备
          bottomMargin = 40;
        }
        
        // 计算并夹取Y坐标，确保发射器可见且在版权条之上
        {
          const copyrightTop = getCopyrightTopInCanvas();
          let desiredY = canvas.height - player.height - bottomMargin;
          if (Number.isFinite(copyrightTop)) {
            desiredY = Math.min(desiredY, Math.floor(copyrightTop - player.height - 4));
          }
          player.y = Math.max(0, Math.min(canvas.height - player.height, desiredY));
        }
        console.log('发射器位置更新:', { x: player.x, y: player.y, canvasHeight: canvas.height, bottomMargin: bottomMargin });
      }
    }
    
    // 移动端音频解锁函数引用
    let mobileAudioUnlocker = null;
    
    // 开始游戏
    function startGame(difficulty) {
      console.log('Starting game with difficulty:', difficulty);
      
      // 初始化音频上下文（需要用户交互）
      try {
        // 移动端音频启用处理
        if (isMobileDevice) {
          mobileAudioUnlocker = enableMobileAudio();
        }
      } catch (error) {
        console.log('Error initializing audio:', error);
      }
      
      // 隐藏开始界面和暂停界面
      startScreen.classList.add('hidden');
      pauseScreen.style.display = 'none';
      gameOverScreen.classList.remove('show');
      
      // 显示游戏界面
      gameCanvas.classList.remove('hidden');
      scoreDisplay.classList.remove('hidden');
      levelDisplay.classList.remove('hidden');
      progressContainer.classList.remove('hidden');
      pauseButton.classList.remove('hidden');
      musicButton.classList.remove('hidden');
      
      // 初始化游戏状态
      gameState = {
        difficulty: difficulty,
        score: 0,
        gameOver: false,
        paused: false,
        spawnTimer: 0,
        spawnInterval: 800, // 增加念头生成频率，加快游戏节奏
        spawnIntervalDecrease: 30,
        targetScore: 500, // 第一关固定目标分数
        level: 1,
        thoughtsSpawned: 0,
        thoughtsPerLevel: 20,
        // 关卡特定属性
        impulsePenalty: 15, // 增加冲动消费扣分数
        rationalBonus: 20,  // 理性消费得分
        baseThoughtSpeed: 2.0, // 增加念头基础速度
        // 不活跃检测
        inactiveTimer: 0, // 不活跃计时器
        maxInactiveTime: 15000, // 15秒不发射就失败 (毫秒)
        lastShootTime: 0 // 上次发射时间
      };
      
      // 清空游戏元素
      bullets = [];
      thoughts = [];
      hitEffects = [];
      collectibles = [];
      
      // 重置玩家位置
      player.x = canvas.width / 2 - player.width / 2;
      // 启动关卡时设置Y坐标，确保在版权条之上
      {
        const copyrightTop = getCopyrightTopInCanvas();
        let desiredY = canvas.height - player.height - 20;
        if (Number.isFinite(copyrightTop)) {
          desiredY = Math.min(desiredY, Math.floor(copyrightTop - player.height - 4));
        }
        player.y = Math.max(0, Math.min(canvas.height - player.height, desiredY));
      }
      
      // 更新显示
      scoreDisplay.textContent = `节省: ${gameState.score}元`;
      updateLevelDisplay();
      updateProgressBar();
      
      // 显示关卡速度增加 - 每关增加玩家移动速度
      player.speed = 15 + (gameState.level - 1) * 0.5;
      
      // 确保游戏循环正在运行
      if (!gameLoopRunning) {
        gameLoopRunning = true;
        console.log('Starting game loop');
        gameLoop();
      }
      
      // 播放第一关背景音乐
      playBackgroundMusic(gameState.level);
    }
    
    // 检查关卡是否结束
    function checkLevelEnd() {
      // 优化关卡结束判断：当玩家分数达标时，立即进入下一关
      // 移除了要求屏幕上没有剩余念头的条件，确保达到分数就能触发关卡升级
      if (gameState.score >= gameState.targetScore) {
        // 检查是否已经完成所有关卡
        if (gameState.level >= 3) {
          // 游戏完成，显示游戏结束弹窗
          console.log('恭喜完成所有关卡！');
          showGameCompletePopup();
          return;
        }
        
        // 关卡结束，进入下一关
        gameState.level++;
        gameState.thoughtsSpawned = 0;
        
        // 根据不同关卡设置不同的难度
        if (gameState.level === 2) {
          // 第二关设置
          gameState.targetScore = 1500; // 第二关目标分数1500元
          gameState.spawnInterval = Math.max(600, gameState.spawnInterval - 100); // 适度加快生成速度
          gameState.impulsePenalty = 25; // 增加冲动消费扣分
          gameState.rationalBonus = 40; // 理性消费得分更多
          gameState.baseThoughtSpeed = 1.7; // 第二关基础速度1.7，最终速度2.2
        } else if (gameState.level === 3) {
          // 第三关设置
          gameState.targetScore = 5000; // 第三关目标分数5000元
          gameState.spawnInterval = Math.max(550, gameState.spawnInterval - 80); // 适度加快生成速度
          gameState.impulsePenalty = 30; // 进一步增加冲动消费扣分
          gameState.rationalBonus = 50; // 理性消费得分更多
          gameState.baseThoughtSpeed = 1.1; // 第三关基础速度1.1，最终速度2.1
          // 第三关会在spawnThought函数中添加促销机制
        }
        
        // 更新显示
        updateLevelDisplay();
        
        // 显示关卡升级弹窗 - 显示对应关卡的提示信息
        showLevelUpPopup();
        
        // 切换到新关卡的背景音乐
        playBackgroundMusic(gameState.level);
        
        // 播放升级音效
        try {
          if (levelUpSound) {
            levelUpSound.currentTime = 0;
            levelUpSound.play().catch(e => console.log('Error playing playing level up sound:', e));
          }
        } catch (error) {
          console.log('Error playing level up sound:', error);
        }
      }
    }
    
    // 显示关卡升级弹窗
    function showLevelUpPopup() {
      console.log('显示关卡升级弹窗，当前关卡:', gameState.level);
      // 暂停游戏
      gameState.paused = true;
      
      // 确保按钮事件监听器正常工作
      if (continueButton) {
        console.log('继续按钮存在，可以点击');
      } else {
        console.log('继续按钮不存在');
      }
      
      // 更新弹窗内容
      newLevelNumberElement.textContent = gameState.level;
      newTargetScoreElement.textContent = gameState.targetScore;
      
      // 根据关卡设置不同的消息和提示
      // 严格按照需求设置每一关的警告信息
      let messages = [
        "你成功抵制了冲动消费，太棒了！",
        "第二关开始！挑战升级！",
        "第三关开始！最终挑战！"
      ];
      
      let hints = [
        "警告：下一关节省要求1500元！冲动消费将扣分更多，理性消费得分也更多，念头速度会加快！",
        "警告：下一关会出现促销信息！带有促销字样的念头得失分加倍！",
        "终极挑战！速度更快，促销念头更多，得失分更高！"
      ];
      
      // 确保消息和提示正确显示
      // 注意索引：当显示第2关时，我们使用索引0（第一关完成后的提示）
      // 当显示第3关时，我们使用索引1（第二关完成后的提示）
      const hintIndex = gameState.level - 2; // 得到0或1，对应第一关和第二关完成后的提示
      
      levelUpMessageElement.textContent = messages[Math.min(gameState.level - 1, messages.length - 1)];
      levelUpHintElement.textContent = hints[Math.min(hintIndex, hints.length - 1)];
      
      // 显示弹窗
      levelUpPopup.classList.remove('hidden');
    }
    
    // 游戏循环
    function gameLoop(currentTime = 0) {
      if (gameState.gameOver) return;
      
      // 计算实际时间间隔
      const deltaTime = currentTime - lastFrameTime;
      
      // 帧率控制 - 只在移动设备上启用
      if (performanceMode && deltaTime < frameInterval) {
        requestAnimationFrame(gameLoop);
        return;
      }
      lastFrameTime = currentTime;
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // 如果游戏没有暂停，更新游戏状态
      if (!gameState.paused) {
        update(deltaTime);
      }
      
      // 即使游戏暂停，也允许移动瞄准点
      if (movingLeft) player.x -= player.speed;
      if (movingRight) player.x += player.speed;
      
      // 限制玩家在屏幕内
      player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));
      
      draw();
      
      requestAnimationFrame(gameLoop);
    }
    
    // 更新游戏状态
    function update(deltaTime = 16.67) { // 默认60FPS的时间间隔
      if (gameState.paused) return;
      
      // 检查不活跃状态 - 如果15秒没有发射，游戏失败
      gameState.inactiveTimer += deltaTime;
      if (gameState.inactiveTimer >= gameState.maxInactiveTime) {
        console.log('玩家长时间不活跃，游戏失败');
        // 确保分数低于目标分数，这样会显示失败消息
        gameState.score = Math.min(gameState.score, gameState.targetScore - 1);
        endGame();
        return;
      }
      
      // 生成消费念头 - 使用实际时间间隔
      gameState.spawnTimer += deltaTime;
      if (gameState.spawnTimer >= gameState.spawnInterval) {
        spawnThought();
        gameState.spawnTimer = 0;
      }
      
      // 更新子弹
      for (let i = bullets.length - 1; i >= 0; i--) {
        bullets[i].y -= bullets[i].speed;
        
        // 检查是否超出屏幕顶部
        if (bullets[i].y + bullets[i].height < 0) {
          returnBulletToPool(bullets[i]);
          bullets.splice(i, 1);
        } else {
          // 检查与消费念头的碰撞
          checkBulletCollision(i);
        }
      }
      
      // 更新消费念头
      for (let i = thoughts.length - 1; i >= 0; i--) {
        thoughts[i].y += thoughts[i].speed;
        thoughts[i].angle += thoughts[i].rotationSpeed;
        
        // 更新对话文本计时器
        if (thoughts[i].showAppearText) {
          thoughts[i].appearTextTimer++;
          if (thoughts[i].appearTextTimer >= thoughts[i].maxAppearTextTime) {
            thoughts[i].showAppearText = false;
          }
        }
        
        // 检查是否超出屏幕底部
        if (thoughts[i].y > canvas.height) {
          // 放过了消费念头
          if (thoughts[i].type === 'impulse') {
            // 放过冲动消费，扣分 - 使用游戏状态中的扣分值
            let penalty = gameState.impulsePenalty;
            // 第三关恶魔未击中扣分加倍
            if (gameState.level === 3) {
              penalty *= 2;
            }
            // 如果是促销念头，扣分加倍
            if (thoughts[i].isPromotion) {
              penalty *= 2;
            }
            gameState.score -= penalty;
            gameState.score = Math.max(0, gameState.score);
            scoreDisplay.textContent = `节省: ${gameState.score}元`;
            updateProgressBar();
          } else {
            // 放过理性消费，加分 - 使用游戏状态中的得分值
            let bonus = gameState.rationalBonus;
            // 如果是促销念头，得分加倍
            if (thoughts[i].isPromotion) {
              bonus *= 2;
            }
            gameState.score += bonus;
            scoreDisplay.textContent = `节省: ${gameState.score}元`;
            updateProgressBar();
          }
          
          // 从数组中移除
          returnThoughtToPool(thoughts[i]);
          thoughts.splice(i, 1);
        }
      }
      
      // 更新击中效果
      for (let i = hitEffects.length - 1; i >= 0; i--) {
        const effect = hitEffects[i];
        effect.life--;
        if (effect.life <= 0) {
          returnEffectToPool(effect);
          hitEffects.splice(i, 1);
        }
      }
      
      // 更新击中对话文本
      for (let i = hitTexts.length - 1; i >= 0; i--) {
        const hitText = hitTexts[i];
        hitText.life--;
        
        // 根据文本类型设置不同的飘动速度
        if (hitText.type === 'score_positive' || hitText.type === 'score_negative') {
          hitText.y -= 2; // 分数文本飘动更快
        } else {
          hitText.y -= 1; // 普通文本向上飘动
        }
        
        hitText.opacity = hitText.life / 120; // 渐变透明
        if (hitText.life <= 0) {
          hitTexts.splice(i, 1);
        }
      }
      
      // 更新收集物品
      for (let i = collectibles.length - 1; i >= 0; i--) {
        const collectible = collectibles[i];
        collectible.y += collectible.speed;
        collectible.angle += collectible.rotationSpeed;
        
        // 检查是否超出屏幕底部
        if (collectible.y > canvas.height) {
          collectibles.splice(i, 1);
        } else {
          // 检查与玩家的碰撞
          if (
            player.x < collectible.x + collectible.width &&
            player.x + player.width > collectible.x &&
            player.y < collectible.y + collectible.height &&
            player.y + player.height > collectible.y
          ) {
            // 收集物品，加分
            gameState.score += collectible.value;
            scoreDisplay.textContent = `节省: ${gameState.score}元`;
            updateProgressBar();
            
            // 播放收集音效
            try {
              if (collectSound) {
                collectSound.currentTime = 0;
                collectSound.play().catch(e => console.log('Error playing collect sound:', e));
              }
            } catch (error) {
              console.log('Error playing collect sound:', error);
            }
            
            // 从数组中移除
            collectibles.splice(i, 1);
          }
        }
      }
      
      // 检查是否升级
      checkLevelUp();
      
      // 检查关卡是否结束
      checkLevelEnd();
    }
    
    // 绘制游戏元素
    function draw() {
      // 绘制玩家（瞄准器）
      drawPlayer();
      
      // 绘制子弹
      for (const bullet of bullets) {
        ctx.fillStyle = 'rgba(255, 107, 157, 0.8)';
        ctx.beginPath();
        ctx.arc(bullet.x + bullet.width / 2, bullet.y + bullet.height / 2, bullet.width / 2, 0, Math.PI * 2);
        ctx.fill();
        
        // 只在非性能模式下添加发光效果
        if (!performanceMode) {
          ctx.shadowBlur = 10;
          ctx.shadowColor = 'rgba(255, 107, 157, 0.8)';
          ctx.fill();
          ctx.shadowBlur = 0;
        }
      }
      
      // 绘制消费念头
      for (const thought of thoughts) {
        const image = thought.type === 'impulse' ? impulseImage : rationalImage;
        
        // 检查图片是否加载完成
        if (image.complete) {
          ctx.save();
          ctx.translate(thought.x + thought.width / 2, thought.y + thought.height / 2);
          ctx.rotate(thought.angle);
          
          // 只在非性能模式下添加发光效果
          if (!performanceMode) {
            if (thought.type === 'impulse') {
              ctx.shadowBlur = 15;
              ctx.shadowColor = 'rgba(255, 107, 157, 0.7)';
            } else {
              ctx.shadowBlur = 15;
              ctx.shadowColor = 'rgba(126, 217, 87, 0.7)';
            }
          }
          
          // 如果是促销消费，添加特殊效果
          if (thought.isPromotion) {
            // 绘制边框（性能模式下简化）
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = performanceMode ? 2 : 3;
            ctx.beginPath();
            ctx.arc(0, 0, thought.width / 2 + 5, 0, Math.PI * 2);
            ctx.stroke();
            
            // 绘制促销文字
            ctx.font = 'bold 14px Arial Rounded MT Bold';
            ctx.fillStyle = '#FFD700';
            ctx.textAlign = 'center';
            ctx.fillText('促销', 0, -thought.height / 2 - 5);
            
            // 性能模式下简化闪烁效果
            if (performanceMode) {
              // 使用简单的透明度切换而不是连续计算
              ctx.globalAlpha = Math.floor(Date.now() / 500) % 2 ? 0.8 : 1.0;
            } else {
              // 原有的平滑闪烁效果
              const flashIntensity = 0.7 + Math.sin(Date.now() / 200) * 0.3;
              ctx.globalAlpha = flashIntensity;
            }
          }
          
          ctx.drawImage(image, -thought.width / 2, -thought.height / 2, thought.width, thought.height);
          
          // 如果是促销消费，绘制加倍提示
          if (thought.isPromotion) {
            ctx.font = 'bold 16px Arial Rounded MT Bold';
            ctx.fillStyle = '#FFFFFF';
            ctx.textAlign = 'center';
            ctx.fillText('×2', 0, thought.height / 2 + 20);
          }
          
          ctx.restore();
        } else {
          // 如果图片未加载完成，绘制占位符
          ctx.fillStyle = thought.type === 'impulse' ? 'rgba(255, 107, 157, 0.8)' : 'rgba(126, 217, 87, 0.8)';
          ctx.beginPath();
          ctx.arc(thought.x + thought.width / 2, thought.y + thought.height / 2, thought.width / 2, 0, Math.PI * 2);
          ctx.fill();
          
          // 如果是促销消费，添加促销文字
          if (thought.isPromotion) {
            ctx.font = 'bold 14px Arial Rounded MT Bold';
            ctx.fillStyle = '#FFD700';
            ctx.textAlign = 'center';
            ctx.fillText('促销', thought.x + thought.width / 2, thought.y - 5);
            
            ctx.font = 'bold 16px Arial Rounded MT Bold';
            ctx.fillStyle = '#FFFFFF';
            ctx.textAlign = 'center';
            ctx.fillText('×2', thought.x + thought.width / 2, thought.y + thought.height + 20);
          }
        }
        
        // 绘制出现对话文本（垂直居中文本）
        if (thought.showAppearText && thought.appearText) {
          ctx.save();
          ctx.font = 'bold 14px Arial';
          ctx.fillStyle = thought.type === 'impulse' ? '#FF6B9D' : '#7ED957';
          ctx.strokeStyle = '#FFFFFF';
          ctx.lineWidth = 2;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          
          // 文本与背景框
          const text = thought.appearText;
          const textWidth = ctx.measureText(text).width;
          const bgHeight = 20; // 背景高度固定，便于居中
          const bgX = thought.x + thought.width / 2 - textWidth / 2 - 5;
          const bgY = thought.y - 35;
          const bgCenterY = bgY + bgHeight / 2;
          
          // 背景与描边
          ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
          ctx.fillRect(bgX, bgY, textWidth + 10, bgHeight);
          ctx.strokeStyle = thought.type === 'impulse' ? '#FF6B9D' : '#7ED957';
          ctx.lineWidth = 2;
          ctx.strokeRect(bgX, bgY, textWidth + 10, bgHeight);
          
          // 居中文本
          ctx.fillStyle = thought.type === 'impulse' ? '#FF6B9D' : '#7ED957';
          ctx.fillText(text, thought.x + thought.width / 2, bgCenterY);
          
          ctx.restore();
        }
      }
      
      // 绘制击中效果
      for (const effect of hitEffects) {
        const alpha = effect.life / 30;
        const scale = 1 + (1 - alpha) * 2;
        
        ctx.save();
        ctx.translate(effect.x, effect.y);
        ctx.scale(scale, scale);
        
        // 外圈
        ctx.strokeStyle = `rgba(255, 215, 0, ${alpha})`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(0, 0, 40, 0, Math.PI * 2);
        ctx.stroke();
        
        // 内圈
        ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(0, 0, 20, 0, Math.PI * 2);
        ctx.stroke();
        
        ctx.restore();
      }
      
      // 绘制击中对话文本
      for (const hitText of hitTexts) {
        ctx.save();
        
        // 根据文本类型设置不同的样式
        if (hitText.type === 'score_positive') {
          // 加分显示：绿色，更大字体，更强对比度
          ctx.font = 'bold 32px Arial';
          ctx.fillStyle = `rgba(0, 255, 0, ${hitText.opacity})`;
          ctx.strokeStyle = `rgba(0, 0, 0, ${hitText.opacity * 0.9})`;
          ctx.lineWidth = 4;
        } else if (hitText.type === 'score_negative') {
          // 扣分显示：红色，更大字体，更强对比度
          ctx.font = 'bold 32px Arial';
          ctx.fillStyle = `rgba(255, 50, 50, ${hitText.opacity})`;
          ctx.strokeStyle = `rgba(255, 255, 255, ${hitText.opacity * 0.9})`;
          ctx.lineWidth = 4;
        } else {
          // 普通文本：亮黄色，更大字体，更强描边
          ctx.font = 'bold 22px Arial';
          ctx.fillStyle = `rgba(255, 255, 100, ${hitText.opacity})`;
          ctx.strokeStyle = `rgba(0, 0, 0, ${hitText.opacity * 0.8})`;
          ctx.lineWidth = 3;
        }
        
        ctx.textAlign = 'center';
        
        // 绘制文本描边
        ctx.strokeText(hitText.text, hitText.x, hitText.y);
        // 绘制文本
        ctx.fillText(hitText.text, hitText.x, hitText.y);
        
        ctx.restore();
      }
      
      // 绘制收集物品
      for (const collectible of collectibles) {
        // 检查图片是否加载完成
        if (coinImage.complete) {
          ctx.save();
          ctx.translate(collectible.x + collectible.width / 2, collectible.y + collectible.height / 2);
          
          // 添加旋转动画
          ctx.rotate(collectible.angle);
          
          // 添加发光效果
          ctx.shadowBlur = 15;
          ctx.shadowColor = 'rgba(255, 215, 0, 0.7)';
          
          // 绘制金币
          ctx.drawImage(coinImage, -collectible.width / 2, -collectible.height / 2, collectible.width, collectible.height);
          
          ctx.restore();
        } else {
          // 如果图片未加载完成，绘制占位符
          ctx.fillStyle = 'rgba(255, 215, 0, 0.8)';
          ctx.beginPath();
          ctx.arc(collectible.x + collectible.width / 2, collectible.y + collectible.height / 2, collectible.width / 2, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // 添加分数文字
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 14px Arial Rounded MT Bold';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(`+${collectible.value}`, collectible.x + collectible.width / 2, collectible.y + collectible.height / 2);
      }
    }
    
    // 绘制玩家（发射器）
    function drawPlayer() {
      // 在绘制前重置关键状态，避免Safari上被透明度、合成或变换影响
      ctx.save();
      ctx.globalAlpha = 1;
      ctx.globalCompositeOperation = 'source-over';
      if (typeof ctx.setTransform === 'function') {
        ctx.setTransform(1, 0, 0, 1, 0, 0);
      }

      const px = Math.round(player.x);
      const py = Math.round(player.y);
      const pw = Math.round(player.width);
      const ph = Math.round(player.height);

      if (launcherImage.complete && launcherImage.naturalWidth > 0) {
        // 添加发射器发光效果
        ctx.shadowBlur = 20;
        ctx.shadowColor = 'rgba(255, 107, 157, 0.6)';
        
        // 绘制发射器（使用整数坐标，提升Safari渲染稳定性）
        ctx.drawImage(launcherImage, px, py, pw, ph);
        
        // 重置阴影
        ctx.shadowBlur = 0;
      } else {
        // 绘制发射器占位符（改为蓝色以便Safari可见）
        ctx.fillStyle = 'rgba(86, 204, 242, 0.9)';
        ctx.beginPath();
        ctx.moveTo(px + pw / 2, py);
        ctx.lineTo(px + pw, py + ph * 0.7);
        ctx.lineTo(px + pw * 0.8, py + ph);
        ctx.lineTo(px + pw * 0.2, py + ph);
        ctx.lineTo(px, py + ph * 0.7);
        ctx.closePath();
        ctx.fill();
        
        // 添加发射器细节高光
        ctx.fillStyle = 'rgba(255, 255, 255, 0.25)';
        ctx.beginPath();
        ctx.moveTo(px + pw / 2, py + ph * 0.2);
        ctx.lineTo(px + pw * 0.7, py + ph * 0.6);
        ctx.lineTo(px + pw * 0.5, py + ph * 0.8);
        ctx.lineTo(px + pw * 0.3, py + ph * 0.6);
        ctx.closePath();
        ctx.fill();
      }

      ctx.restore();
    }
    
    // 生成消费念头
    function spawnThought() {
      // 移除念头数量限制，持续生成直到玩家达到目标分数
      // 这样玩家可以通过多次生成念头来积累足够的分数
      
      // 根据关卡调整冲动消费和理性消费的比例
      let impulseProbability = 0.65; // 第一关：冲动消费65%，理性消费35%
      if (gameState.level === 2) {
        impulseProbability = 0.7; // 第二关：冲动消费70%，理性消费30%
      } else if (gameState.level === 3) {
        impulseProbability = 0.75; // 第三关：冲动消费75%，理性消费25%
      }
      
      const type = Math.random() < impulseProbability ? 'impulse' : 'rational';
      const width = 60;
      const height = 60;
      
      // 使用gameState中的基础速度，根据关卡动态调整
      const speed = gameState.baseThoughtSpeed + (gameState.level - 1) * 0.5;
      
      // 第三关开始有更高概率出现促销字样 - 50%概率
      const isPromotion = gameState.level >= 3 && Math.random() < 0.5; // 50%概率出现促销
      
      // 添加对话文本
      let appearText = '';
      let hitText = '';
      let shouldShowText = false;
      
      // 第一关：100%显示对话
      // 第二、三关：20%概率显示对话
      if (gameState.level === 1) {
        shouldShowText = true;
      } else if (gameState.level >= 2) {
        shouldShowText = Math.random() < 0.2; // 20%概率
      }
      
      // 为所有思维泡泡设置hitText（击中时的反馈），不管是否显示appearText
      if (type === 'impulse') {
        // 冲动消费出现时的诱惑性句子和击中时的反馈
        let impulseAppearTexts = [];
        let impulseHitTexts = [];
        
        if (gameState.level === 1) {
          impulseAppearTexts = [
            "我们一起买买买吧",
            "买东西心情好",
            "不买怎么体验人生？",
            "限时优惠不买就亏了",
            "这个必须拥有！"
          ];
          impulseHitTexts = [
            "啊~我还会再来的",
            "死了一个我还有千万个我",
            "你保住了这笔钱，那下次呢",
            "我会回来的！",
            "这次算你赢了"
          ];
        } else if (gameState.level === 2) {
          impulseAppearTexts = [
            "双11大促销！不买就亏了",
            "限时折扣，错过就没了",
            "这个价格太划算了",
            "囤货季节到了",
            "买多送多，超值优惠",
            "今天不买明天涨价"
          ];
          impulseHitTexts = [
            "促销还会继续的...",
            "下次双12见！",
            "你错过了好价格",
            "还有618等着你",
            "我会带着更大折扣回来",
            "这只是开始..."
          ];
        } else if (gameState.level === 3) {
          impulseAppearTexts = [
            "终极狂欢！史上最低价",
            "最后机会！清仓大甩卖",
            "VIP专享价，仅此一次",
            "秒杀倒计时开始",
            "全场包邮还送礼品",
            "这辈子最便宜的价格"
          ];
          impulseHitTexts = [
            "你居然抵挡住了终极诱惑",
            "败给了理性...可恶",
            "下次我会更强的",
            "终极形态还没展现",
            "你的意志力太强了",
            "这次算你厉害"
          ];
        }
        
        // 设置hitText（所有思维泡泡都有）
        hitText = impulseHitTexts[Math.floor(Math.random() * impulseHitTexts.length)];
        // 只有shouldShowText为true时才设置appearText
        if (shouldShowText) {
          appearText = impulseAppearTexts[Math.floor(Math.random() * impulseAppearTexts.length)];
        }
      } else {
        // 理性消费出现时的句子和击中时的反馈
        let rationalAppearTexts = [];
        let rationalHitTexts = [];
        
        if (gameState.level === 1) {
          rationalAppearTexts = [
            "我来帮你省钱啦",
            "理性消费",
            "只买需要的",
            "三思而后行",
            "省钱就是赚钱"
          ];
          rationalHitTexts = [
            "误伤友军啊~",
            "这下省不了钱了",
            "我是来帮你的呀",
            "为什么要打我",
            "理性消费很重要啊"
          ];
        } else if (gameState.level === 2) {
          rationalAppearTexts = [
            "冷静！先看看真的需要吗",
            "对比一下其他商家价格",
            "想想你的预算还够吗",
            "这个真的比平时便宜吗",
            "理性分析，避免冲动",
            "省下的钱可以做更多事"
          ];
          rationalHitTexts = [
            "理性被冲动打败了...",
            "这样会花更多钱的",
            "我只是想帮你省钱",
            "冷静思考很重要啊",
            "不听劝告会后悔的",
            "理智去哪了..."
          ];
        } else if (gameState.level === 3) {
          rationalAppearTexts = [
            "最后防线！坚持住",
            "想想你的存款余额",
            "这些真的都需要吗",
            "理性消费，拒绝套路",
            "保持清醒，别被忽悠",
            "你的钱包在哭泣"
          ];
          rationalHitTexts = [
            "最后的理智也没了...",
            "完了，彻底沦陷了",
            "钱包要空了",
            "理性彻底败北",
            "我已经尽力了",
            "希望你不会后悔"
          ];
        }
        
        // 设置hitText（所有思维泡泡都有）
        hitText = rationalHitTexts[Math.floor(Math.random() * rationalHitTexts.length)];
        // 只有shouldShowText为true时才设置appearText
        if (shouldShowText) {
          appearText = rationalAppearTexts[Math.floor(Math.random() * rationalAppearTexts.length)];
        }
      }
      
      const thought = getThoughtFromPool();
      thought.x = Math.random() * (canvas.width - width);
      thought.y = -height;
      thought.width = width;
      thought.height = height;
      thought.type = type;
      thought.speed = speed;
      thought.angle = 0;
      thought.rotationSpeed = (Math.random() - 0.5) * 0.1;
      thought.isPromotion = isPromotion;
      thought.appearText = appearText;
      thought.hitText = hitText;
      thought.showAppearText = shouldShowText;
      thought.appearTextTimer = 0;
      thought.maxAppearTextTime = 120; // 显示2秒（60fps * 2）
      
      thoughts.push(thought);
      
      // 增加已生成念头计数
      gameState.thoughtsSpawned++;
      
      console.log(`生成消费念头: ${type}, 促销: ${isPromotion}, 速度: ${speed.toFixed(1)}, 关卡: ${gameState.level}`);
    }
    
    // 生成收集物品
    function spawnCollectible(x, y) {
      // 随机价值（10或20分）
      const value = Math.random() < 0.5 ? 10 : 20;
      
      collectibles.push({
        x: x - 20, // 调整位置使其居中
        y: y - 20,
        width: 40,
        height: 40,
        speed: 3,
        value: value,
        angle: 0,
        rotationSpeed: 0.1
      });
    }
    
    // 发射子弹
    function shootBullet() {
      const bullet = getBulletFromPool();
      bullet.x = player.x + player.width / 2 - 5;
      bullet.y = player.y;
      bullet.width = 10;
      bullet.height = 20;
      bullet.speed = 15;
      bullets.push(bullet);
      
      // 重置不活跃计时器
      gameState.inactiveTimer = 0;
      gameState.lastShootTime = Date.now();
      
      // 播放射击音效
      try {
        if (shootSound) {
          shootSound.currentTime = 0;
          shootSound.play().catch(e => console.log('Error playing shoot sound:', e));
        }
      } catch (error) {
        console.log('Error playing shoot sound:', error);
      }
    }
    
    // 添加击中效果
    function addHitEffect(x, y) {
      const effect = getEffectFromPool();
      effect.x = x;
      effect.y = y;
      effect.life = 30;
      hitEffects.push(effect);
    }
    
    // 显示击中时的对话文本
    function showHitText(x, y, text, type = 'normal') {
      hitTexts.push({
        x: x,
        y: y,
        text: text,
        type: type, // 'normal', 'score_positive', 'score_negative'
        life: 120, // 显示2秒（60fps * 2）
        opacity: 1.0
      });
    }
    
    // 检查子弹与消费念头的碰撞
    function checkBulletCollision(bulletIndex) {
      const bullet = bullets[bulletIndex];
      
      for (let i = thoughts.length - 1; i >= 0; i--) {
        const thought = thoughts[i];
        
        if (
          bullet.x < thought.x + thought.width &&
          bullet.x + bullet.width > thought.x &&
          bullet.y < thought.y + thought.height &&
          bullet.y + bullet.height > thought.y
        ) {
          // 第一关100%显示被击中时的对话，第二三关20%概率显示
          let shouldShowHitText = false;
          if (gameState.level === 1) {
            shouldShowHitText = true;
          } else if (gameState.level >= 2) {
            shouldShowHitText = Math.random() < 0.2; // 20%概率显示
          }
          
          if (shouldShowHitText && thought.hitText) {
            showHitText(thought.x + thought.width / 2, thought.y + thought.height / 2, thought.hitText);
          }
          
          // 击中消费念头
          if (thought.type === 'impulse') {
            // 击中冲动消费，加分 - 使用游戏状态中的理性消费得分值（作为击中冲动消费的奖励）
            let points = gameState.rationalBonus;
            // 如果是促销消费，分数加倍
            if (thought.isPromotion) {
              points *= 2;
            }
            gameState.score += points;
            
            // 显示加分数值（恶魔被击中显示+分数）
            showHitText(thought.x + thought.width / 2, thought.y + thought.height / 2 - 30, `+${points}元`, 'score_positive');
            
            // 添加击中效果
            addHitEffect(thought.x + thought.width / 2, thought.y + thought.height / 2);
            
            // 播放击中冲动消费音效（增强版）
            try {
              if (hitImpulseSound) {
                hitImpulseSound.currentTime = 0;
                // 随机音调变化，让音效更有趣
                hitImpulseSound.playbackRate = 0.8 + Math.random() * 0.6; // 0.8-1.4倍速
                // 随机音量变化
                hitImpulseSound.volume = 0.6 + Math.random() * 0.3; // 0.6-0.9音量
                hitImpulseSound.play().catch(e => console.log('Error playing impulse sound:', e));
              }
            } catch (error) {
              console.log('Error playing impulse sound:', error);
            }
            
            // 有概率掉落收集物品
            if (Math.random() < 0.5) {
              spawnCollectible(thought.x + thought.width / 2, thought.y + thought.height / 2);
            }
          } else {
            // 击中理性消费，扣分 - 使用游戏状态中的冲动消费扣分值
            let penalty = gameState.impulsePenalty * 2; // 击中理性消费扣双倍分数
            // 第二关开始扣分更多
            if (gameState.level >= 2) {
              penalty *= 1.5; // 第二关开始再增加50%的扣分
            }
            // 如果是促销消费，扣分也加倍
            if (thought.isPromotion) {
              penalty *= 2;
            }
            gameState.score -= penalty;
            gameState.score = Math.max(0, gameState.score);
            
            // 显示扣分数值（天使被击中显示-分数）
            showHitText(thought.x + thought.width / 2, thought.y + thought.height / 2 - 30, `-${penalty}元`, 'score_negative');
            
            // 播放击中理性消费音效（增强版）
            try {
              if (hitRationalSound) {
                hitRationalSound.currentTime = 0;
                // 为击中天使添加不同的音调变化，更低沉一些表示警告
                hitRationalSound.playbackRate = 0.6 + Math.random() * 0.4; // 0.6-1.0倍速，更低沉
                // 音量稍微大一些，表示这是不好的行为
                hitRationalSound.volume = 0.7 + Math.random() * 0.2; // 0.7-0.9音量
                hitRationalSound.play().catch(e => console.log('Error playing rational sound:', e));
              }
            } catch (error) {
              console.log('Error playing rational sound:', error);
            }
          }
          
          // 更新分数显示
          scoreDisplay.textContent = `节省: ${gameState.score}元`;
          updateProgressBar();
          
          // 从数组中移除子弹和消费念头
          returnBulletToPool(bullets[bulletIndex]);
          bullets.splice(bulletIndex, 1);
          returnThoughtToPool(thoughts[i]);
          thoughts.splice(i, 1);
          
          break;
        }
      }
    }
    
    // 更新进度条
    function updateProgressBar() {
      const progress = Math.min(100, (gameState.score / gameState.targetScore) * 100);
      progressBar.style.width = `${progress}%`;
    }
    
    // 检查是否升级 - 仅显示视觉反馈，不实际升级关卡
    function checkLevelUp() {
      // 暂时禁用此函数的功能，避免与checkLevelEnd函数冲突
      // 关卡升级逻辑完全由checkLevelEnd函数处理
      // 这样可以确保当进度条满了并且屏幕清空时，立即显示过关提示
      return;
    }
    
    // 暂停游戏
    function pauseGame() {
      if (gameState.gameOver) return;
      
      gameState.paused = true;
      pauseScreen.style.display = 'flex';
      
      // 暂停背景音乐
      if (currentBackgroundMusic && !currentBackgroundMusic.paused) {
        currentBackgroundMusic.pause();
      }
      
      // 播放暂停音效
      try {
        if (pauseSound && !pauseSound.paused) {
          pauseSound.pause();
          pauseSound.currentTime = 0;
        }
        if (pauseSound) {
          pauseSound.play().catch(e => console.log('Error playing pause sound:', e));
        }
      } catch (error) {
        console.log('Error playing pause sound:', error);
      }
    }
    
    // 继续游戏
    function resumeGame() {
      gameState.paused = false;
      pauseScreen.style.display = 'none';
      
      // 恢复背景音乐
      if (currentBackgroundMusic && currentBackgroundMusic.paused && musicEnabled) {
        try {
          currentBackgroundMusic.play().catch(e => console.log('Error resuming background music:', e));
        } catch (error) {
          console.log('Error resuming background music:', error);
        }
      }
      
      // 播放暂停音效（复用）
      try {
        if (pauseSound && !pauseSound.paused) {
          pauseSound.pause();
          pauseSound.currentTime = 0;
        }
        if (pauseSound) {
          pauseSound.play().catch(e => console.log('Error playing resume sound:', e));
        }
      } catch (error) {
        console.log('Error playing resume sound:', error);
      }
    }
    
    // 结束游戏
    function endGame() {
      gameState.gameOver = true;
      
      // 显示游戏结束界面
      finalScoreElement.textContent = gameState.score;
      
      // 根据得分设置状态信息
      if (gameState.score >= gameState.targetScore) {
        scoreStatusElement.textContent = '恭喜你成功抵制了冲动消费！';
      } else {
        scoreStatusElement.textContent = '冲动消费占上风，钱包保卫战失败，钱全花光啦~~~';
      }
      
      gameOverScreen.classList.add('show');
      
      // 播放游戏结束音效（柔和版）
      try {
        if (gameOverSound) {
          gameOverSound.currentTime = 0;
          // 让失败音效更柔和
          gameOverSound.volume = 0.3; // 降低音量到30%
          gameOverSound.playbackRate = 0.8; // 降低播放速度，让声音更低沉柔和
          
          // 限制失败音效只播放2秒（大约两下警报声）
          gameOverSound.play().catch(e => console.log('Error playing game over sound:', e));
          
          // 1.5秒后开始渐出效果
          let fadeOutTimeout = setTimeout(() => {
            if (gameOverSound && !gameOverSound.paused) {
              // 渐出效果
              let fadeOutInterval = setInterval(() => {
                if (gameOverSound && gameOverSound.volume > 0.05) {
                  gameOverSound.volume = Math.max(0, gameOverSound.volume - 0.05);
                } else {
                  if (gameOverSound) {
                    gameOverSound.pause();
                    gameOverSound.currentTime = 0;
                    gameOverSound.volume = 0.5; // 重置音量为默认值
                    gameOverSound.playbackRate = 1.0; // 重置播放速度
                  }
                  clearInterval(fadeOutInterval);
                }
              }, 50);
              
              // 安全措施：2秒后强制清理定时器
              setTimeout(() => {
                clearInterval(fadeOutInterval);
                if (gameOverSound) {
                  gameOverSound.pause();
                  gameOverSound.currentTime = 0;
                  gameOverSound.volume = 0.5;
                  gameOverSound.playbackRate = 1.0;
                }
              }, 2000);
            }
          }, 1500);
        }
      } catch (error) {
        console.log('Error playing game over sound:', error);
      }
      
      // 重置游戏循环状态
      gameLoopRunning = false;
    }
    
    // 处理键盘按下事件
    function handleKeyDown(event) {
      if (gameState.gameOver) return;
      
      switch (event.key) {
        case 'ArrowLeft':
          movingLeft = true;
          break;
        case 'ArrowRight':
          movingRight = true;
          break;
        case ' ':
          shootBullet();
          break;
        case 'p':
        case 'P':
          if (gameState.paused) {
            resumeGame();
          } else {
            pauseGame();
          }
          break;
      }
    }
    
    // 处理键盘松开事件
    function handleKeyUp(event) {
      switch (event.key) {
        case 'ArrowLeft':
          movingLeft = false;
          break;
        case 'ArrowRight':
          movingRight = false;
          break;
      }
    }
    
    // 处理画布点击事件
    function handleCanvasClick(event) {
      if (gameState.gameOver || gameState.paused) return;
      
      const rect = canvas.getBoundingClientRect();
      const clickX = event.clientX - rect.left;
      
      // 直接将发射装置移动到点击位置
      player.x = clickX - player.width / 2;
      
      // 限制玩家在屏幕内
      player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));
      
      // 发射子弹
      shootBullet();
    }
    
    // 处理鼠标移动事件
    function handleMouseMove(event) {
      if (gameState.gameOver) return;
      
      const rect = canvas.getBoundingClientRect();
      const mouseX = event.clientX - rect.left;
      
      // 更新玩家位置到鼠标位置
      player.x = mouseX - player.width / 2;
      
      // 限制玩家在屏幕内
      player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));
    }
    
    // 处理触摸开始事件
    function handleTouchStart(event) {
      if (gameState.gameOver || gameState.paused) return;
      
      event.preventDefault();
      const touch = event.touches[0];
      const rect = canvas.getBoundingClientRect();
      const touchX = touch.clientX - rect.left;
      
      // 直接将发射装置移动到触摸位置
      player.x = touchX - player.width / 2;
      
      // 限制玩家在屏幕内
      player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));
      
      // 发射子弹
      shootBullet();
    }
    
    // 处理触摸移动事件
    function handleTouchMove(event) {
      if (gameState.gameOver || gameState.paused) return;
      
      event.preventDefault();
      const touch = event.touches[0];
      const rect = canvas.getBoundingClientRect();
      const touchX = touch.clientX - rect.left;
      
      // 实时跟随触摸位置移动发射装置
      player.x = touchX - player.width / 2;
      
      // 限制玩家在屏幕内
      player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));
    }
    
    // 处理触摸结束事件
    function handleTouchEnd(event) {
      event.preventDefault();
      
      // 触摸结束时停止移动（如果有连续移动的话）
      movingLeft = false;
      movingRight = false;
    }
    
    // 页面加载完成后初始化游戏
    window.addEventListener('load', init);
  </script>
</body>
</html>
